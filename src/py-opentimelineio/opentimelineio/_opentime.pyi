from typing import Any, ClassVar

from typing import overload

class RationalTime:
    __hash__: ClassVar[None] = ...
    def __init__(self, value: float = ..., rate: float = ...) -> None: ...
    def almost_equal(self, other: RationalTime, delta: float = ...) -> bool: ...
    def duration_from_start_end_time(self, *args, **kwargs) -> Any: ...
    def duration_from_start_end_time_inclusive(self, *args, **kwargs) -> Any: ...
    def from_frames(self, *args, **kwargs) -> Any: ...
    def from_seconds(self, *args, **kwargs) -> Any: ...
    def from_time_string(self, *args, **kwargs) -> Any: ...
    def from_timecode(self, *args, **kwargs) -> Any: ...
    def is_invalid_time(self) -> bool: ...
    def is_valid_timecode_rate(self, *args, **kwargs) -> Any: ...
    def nearest_valid_timecode_rate(self, *args, **kwargs) -> Any: ...
    @overload
    def rescaled_to(self, new_rate: float) -> RationalTime: ...
    @overload
    def rescaled_to(self, other: RationalTime) -> RationalTime: ...
    @overload
    def to_frames(self) -> int: ...
    @overload
    def to_frames(self, rate: float) -> int: ...
    def to_seconds(self) -> float: ...
    def to_time_string(self) -> str: ...
    @overload
    def to_timecode(self, rate: float, drop_frame: object) -> str: ...
    @overload
    def to_timecode(self, rate: float) -> str: ...
    @overload
    def to_timecode(self) -> str: ...
    @overload
    def value_rescaled_to(self, new_rate: float) -> float: ...
    @overload
    def value_rescaled_to(self, other: RationalTime) -> float: ...
    def __add__(self, arg0: RationalTime) -> RationalTime: ...
    def __copy__(self) -> RationalTime: ...
    def __deepcopy__(self, copier: object = ...) -> RationalTime: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __ge__(self, arg0: object) -> bool: ...
    def __gt__(self, arg0: object) -> bool: ...
    def __iadd__(self, arg0: RationalTime) -> RationalTime: ...
    def __le__(self, arg0: object) -> bool: ...
    def __lt__(self, arg0: object) -> bool: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __neg__(self) -> RationalTime: ...
    def __sub__(self, arg0: RationalTime) -> RationalTime: ...
    @property
    def rate(self) -> float: ...
    @property
    def value(self) -> float: ...

class TimeRange:
    __hash__: ClassVar[None] = ...
    def __init__(self, start_time: RationalTime = ..., duration: RationalTime = ...) -> None: ...
    def before(self, *args, **kwargs) -> Any: ...
    @overload
    def begins(self, other: RationalTime, epsilon_s: float = ...) -> bool: ...
    @overload
    def begins(self, other: TimeRange, epsilon_s: float = ...) -> bool: ...
    @overload
    def begins(this) -> Any: ...
    @overload
    def clamped(self, other: RationalTime) -> RationalTime: ...
    @overload
    def clamped(self, other: TimeRange) -> TimeRange: ...
    def contains(self, *args, **kwargs) -> Any: ...
    def duration_extended_by(self, other: RationalTime) -> TimeRange: ...
    def end_time_exclusive(self) -> RationalTime: ...
    def end_time_inclusive(self) -> RationalTime: ...
    def extended_by(self, other: TimeRange) -> TimeRange: ...
    def finishes(self, *args, **kwargs) -> Any: ...
    def intersects(self, other: TimeRange, epsilon_s: float = ...) -> bool: ...
    @overload
    def meets(self, other: TimeRange, epsilon_s: float = ...) -> bool: ...
    @overload
    def meets(this) -> Any: ...
    def overlaps(self, *args, **kwargs) -> Any: ...
    def range_from_start_end_time(self, *args, **kwargs) -> Any: ...
    def range_from_start_end_time_inclusive(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> TimeRange: ...
    def __deepcopy__(self, arg0: object) -> TimeRange: ...
    def __eq__(self, arg0: TimeRange) -> bool: ...
    def __ne__(self, arg0: TimeRange) -> bool: ...
    @property
    def duration(self) -> RationalTime: ...
    @property
    def start_time(self) -> RationalTime: ...

class TimeTransform:
    __hash__: ClassVar[None] = ...
    def __init__(self, offset: RationalTime = ..., scale: float = ..., rate: float = ...) -> None: ...
    @overload
    def applied_to(self, other: TimeRange) -> TimeRange: ...
    @overload
    def applied_to(self, other: TimeTransform) -> TimeTransform: ...
    @overload
    def applied_to(self, other: RationalTime) -> RationalTime: ...
    def __copy__(self) -> TimeTransform: ...
    def __deepcopy__(self, memo: dict) -> TimeTransform: ...
    def __eq__(self, arg0: TimeTransform) -> bool: ...
    def __ne__(self, arg0: TimeTransform) -> bool: ...
    @property
    def offset(self) -> RationalTime: ...
    @property
    def rate(self) -> float: ...
    @property
    def scale(self) -> float: ...
